colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
# mutate(data, e)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(wdi_data$e)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
# mutate(data, e)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(wdi_data$e)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
mutate(data, e)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(wdi_data$e)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
# mutate(data, e)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
res <- e
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
res <- e
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2, mean(res))
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
b_ols@res
b_ols()@res
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
res <- e
data %<% mutate(.,res)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2, mean(res))
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
#residuals
res <- e
data %>% mutate(.,res)
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2, mean(res))
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
data
b_ols@data
wdi_data
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# If include intercept == TRUE: Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
# Residuals
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
# Function to calculate beta coefficient without an intercept
b_ols <- function(data, y, X, include_i) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y_data <- data %>%
# Select y variable data from 'data'
select_(.dots = y) %>%
#if(include_i)
# Convert y_data to matrices
as.matrix()
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# If include intercept == TRUE: Add a column of ones to front
if(include_i) {X_data <- cbind(1, X_data)
colnames(X_data)[1] <- "ones"}
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
if(include_i){
rownames(beta_hat) <- c("intercept", X)
}
else
rownames(beta_hat) <- c(X)
n <- nrow(X_data)
k <- ncol(X_data)
dof <- n - k
#uncentered R2
e <- (diag(n) - X_data %*% solve(t(X_data) %*% X_data) %*% t(X_data)) %*% y_data
ruc_sq <- (1- ((t(e) %*% e)) / (t(y_data) %*% y_data))
#centered R2
i <- rep(1, n)
A <- (diag(i) - (1/n)*(i) %*% t(i))
y_star = A %*% y_data
r_sq <- 1 - ( (t(e) %*% e) / (t(y_star) %*% y_star) )
#Adjusted R2
adj_r2 <- 1 - (((n-1)/(n-k))*(1-r_sq))
#AIC
aic <- log((t(e) %*% e)/n) + 2*(k/n)
#SIC
sic <- log((t(e) %*% e)/n) + (k/n)*(log(n))
# s2
s2 <- (t(e) %*% e)/(n-k)
# Residuals
reg_list <- c("Beta_hat" = beta_hat, "n" = n, "dof" = dof, "ruc_sq" = ruc_sq, "r_sq" = r_sq, "Adj_R2" = adj_r2, "AIC" = aic, "SIC" = sic, "s2" = s2)
df <- data
df$res <- e
return(reg_list)
}
# Regress CO2pc on GDPpc without an intercept
b_ols(data=wdi_data, y="CO2pc", X="GDPpc", include_i = FALSE)
df
head(wdi_data)
